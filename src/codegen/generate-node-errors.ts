import path from "node:path";
import assert from "node:assert";
import NodeErrors, { ErrorCodeMapping, ErrorConstructor, SimpleMapping } from "../bun.js/bindings/ErrorCode.ts";
const outputDir = process.argv[2];

if (!outputDir) {
  throw new Error("Missing output directory");
}

const Errors: NormalizedMapping[] = NodeErrors.map(normalizeMapping);

const count = Errors.reduce((count, error) => count + error.extraCtors.length, Errors.length);
if (count > 256) {
  // increase size of enum's to have more tags
  // src/bun.js/node/types.zig#Encoding
  // src/bun.js/bindings/BufferEncodingType.h
  throw new Error("NodeError count exceeds u8");
}

let enumHeader = ``; // ErrorCode+List.h
let listHeader = ``; // ErrorCode+Data.h
let zig = ``; // ErrorCode.zig
const factory = { cpp: ``, h: `` }; // ErrorCode+Factory.{h,cpp}

enumHeader = `
// clang-format off
// Generated by: src/codegen/generate-node-errors.ts
// Input:        src/bun.js/bindings/ErrorCode.ts
#pragma once

#include <cstdint>

namespace Bun {
  static constexpr size_t NODE_ERROR_COUNT = ${count};
  enum class ErrorCode : uint8_t {
`;

listHeader = `
// clang-format off
// Generated by: src/codegen/generate-node-errors.ts
#pragma once

#include <JavaScriptCore/ErrorType.h>

struct ErrorCodeData {
    JSC::ErrorType type;
    WTF::ASCIILiteral name;
    WTF::ASCIILiteral code;
};
static constexpr ErrorCodeData errors[${count}] = {
`;

zig = `
// Generated by: src/codegen/generate-node-errors.ts
const std = @import("std");
const bun = @import("root").bun;
const JSC = bun.JSC;

pub fn ErrorBuilder(comptime code: Error, comptime fmt: [:0]const u8, Args: type) type {
  return struct {
      globalThis: *JSC.JSGlobalObject,
      args: Args,

      // Throw this error as a JS exception
      pub inline fn throw(this: @This()) bun.JSError {
        return code.throw(this.globalThis, fmt, this.args);
      }

      /// Turn this into a JSValue
      pub inline fn toJS(this: @This()) JSC.JSValue {
        return code.fmt(this.globalThis, fmt, this.args);
      }

      /// Turn this into a JSPromise that is already rejected.
      pub inline fn reject(this: @This()) JSC.JSValue {
        return JSC.JSPromise.rejectedPromiseValue(this.globalThis, code.fmt(this.globalThis, fmt, this.args));
      }
  };
}

pub const Error = enum(u8) {

`;

factory.h = /* cpp */ `
// clang-format off
// Generated by: src/codegen/generate-node-errors.ts
#pragma once
#include <JavaScriptCore/JSObject.h>
#include <JavaScriptCore/CallFrame.h>
#include <wtf/text/WTFString.h>

namespace Bun {
namespace ERR {

`;
factory.cpp = /* cpp */ `
// clang-format off
// Generated by: src/codegen/generate-node-errors.ts
#include "ErrorCode+Factory.h"
#include "ErrorCode+List.h"
#include "ErrorCode.h"
#include <wtf/text/StringBuilder.h>

namespace Bun {
namespace ERR {

`;

let i = 0;
let listForUsingNamespace = "";
for (const mapping of Errors) {
  let { code, ctor: constructor, name, message, extraCtors } = mapping;
  enumHeader += `    ${code} = ${i},\n`;
  listHeader += `    { JSC::ErrorType::${constructor.name}, "${name}"_s, "${code}"_s },\n`;
  zig += `    /// ${name}: ${code} (instanceof ${constructor.name})\n`;
  zig += `    ${code} = ${i},\n`;
  listForUsingNamespace += ` /// ${name}: ${code} (instanceof ${constructor.name})\n`;
  listForUsingNamespace += ` pub inline fn ${code}(globalThis: *JSC.JSGlobalObject, comptime fmt: [:0]const u8, args: anytype) ErrorBuilder(Error.${code}, fmt, @TypeOf(args)) {\n`;
  listForUsingNamespace += `     return .{ .globalThis = globalThis, .args = args };\n`;
  listForUsingNamespace += ` }\n`;
  i++;

  if (message) {
    const template = parseTemplate(message);
    const { declarations, impls } = renderErrorFactory(mapping, template);
    factory.h += declarations + "\n";
    factory.cpp += impls + "\n\n";
  }

  for (const con of extraCtors) {
    if (con == null) continue;
    if (name == null) name = con.name;
    enumHeader += `    ${code}_${con.name} = ${i},\n`;
    listHeader += `    { JSC::ErrorType::${con.name}, "${con.name}"_s, "${code}"_s },\n`;
    zig += `    /// ${name}: ${code} (instanceof ${con.name})\n`;
    zig += `    ${code}_${con.name} = ${i},\n`;
    listForUsingNamespace += ` /// ${name}: ${code} (instanceof ${con.name})\n`;
    listForUsingNamespace += ` pub inline fn ${code}_${con.name}(globalThis: *JSC.JSGlobalObject, comptime fmt: [:0]const u8, args: anytype) ErrorBuilder(Error.${code}_${con.name}, fmt, @TypeOf(args)) {\n`;
    listForUsingNamespace += `     return .{ .globalThis = globalThis, .args = args };\n`;
    listForUsingNamespace += ` }\n`;
    i++;
  }
}

enumHeader += `
};
} // namespace Bun
`;

listHeader += `
};
`;

factory.h += `

} // namespace ERR
} // namespace Bun
`;
factory.cpp += `

} // namespace ERR
} // namespace Bun
`;

zig += `


  extern fn Bun__createErrorWithCode(globalThis: *JSC.JSGlobalObject, code: Error, message: *bun.String) JSC.JSValue;

  /// Creates an Error object with the given error code.
  /// Derefs the message string.
  pub fn toJS(this: Error, globalThis: *JSC.JSGlobalObject, message: *bun.String) JSC.JSValue {
    defer message.deref();
    return Bun__createErrorWithCode(globalThis, this, message);
  }

  pub fn fmt(this: Error, globalThis: *JSC.JSGlobalObject, comptime fmt_str: [:0]const u8, args: anytype) JSC.JSValue {
    if (comptime std.meta.fieldNames(@TypeOf(args)).len == 0) {
      var message = bun.String.static(fmt_str);
      return toJS(this, globalThis, &message);
    }

    var message = bun.String.createFormat(fmt_str, args) catch bun.outOfMemory();
    return toJS(this, globalThis, &message);
  }

  pub fn throw(this: Error, globalThis: *JSC.JSGlobalObject, comptime fmt_str: [:0]const u8, args: anytype) bun.JSError {
    return globalThis.throwValue(fmt(this, globalThis, fmt_str, args));
  }

};

pub const JSGlobalObjectExtensions = struct {
${listForUsingNamespace}
};
`;

await Bun.write(path.join(outputDir, "ErrorCode+List.h"), enumHeader);
await Bun.write(path.join(outputDir, "ErrorCode+Data.h"), listHeader);
await Bun.write(path.join(outputDir, "ErrorCode.zig"), zig);
await Bun.write(path.join(outputDir, "ErrorCode+Factory.h"), factory.h);
await Bun.write(path.join(outputDir, "ErrorCode+Factory.cpp"), factory.cpp);

// =============================================================================

function renderErrorFactory(error: NormalizedMapping, template: TemplatePart[]) {
  const { code, ctor, name, message } = error;
  assert(message && template.length, "Error factories can only be created for errors with a message");

  const concreteParams = template
    .filter((part): part is TemplatePlaceholder => part.kind === "placeholder")
    .map(({ name }) => ({ name, type: `WTF::String` }) as const);
  const concreteSignature = concreteParams.map(({ name, type }) => `const ${type}& ${name}`).join(", ");

  var declarations = /* cpp */ `
  /// Create a new ${code} error object. This factory may throw an exception.
  /// \`${message}\`
  JSC::JSObject* CREATE_${code}(JSC::JSGlobalObject* globalObject, const JSC::CallFrame* callFrame);
  /// \`${message}\`
  JSC::JSObject* CREATE_${code}(JSC::JSGlobalObject* globalObject, ${concreteSignature});
`;

  var jsFunctionImpl: string = [
    `JSC::JSObject* CREATE_${code}(JSC::JSGlobalObject* globalObject, const JSC::CallFrame* callFrame) {`,
    `    JSC::VM& vm = globalObject->vm();`,
    `    auto scope = DECLARE_THROW_SCOPE(vm);`,
    ``
  ].join("\n");

  let i = 0;
  for (const param of concreteParams) {
    jsFunctionImpl += [
      `    auto arg${i} = callFrame->argument(${i});`,
      `    ${param.type} ${param.name} = arg${i}.toWTFString(globalObject);`,
      `    RETURN_IF_EXCEPTION(scope, {});`,
    ].join("\n");
    i++;
  }

  jsFunctionImpl += [
    ``,
    `    return CREATE_${code}(globalObject, ${concreteParams.map(({ name }) => name).join(", ")});`,
    `}`,
  ].join("\n");

  var concreteImpl = [
    `JSC::JSObject* CREATE_${code}(JSC::JSGlobalObject* globalObject, ${concreteSignature}) {`,
    `    WTF::StringBuilder builder;`,
    ``,
  ].join("\n");
  for (const part of template) {
    switch (part.kind) {
      case "string":
        concreteImpl += `    builder.append("${part.text}"_s);\n`;
        break;
      case "placeholder":
        concreteImpl += `    builder.append(${part.name});\n`;
        break;
      default:
        throw new TypeError(`Invalid template part: unknown kind ${(part as any).kind}`);
    }
  }

  concreteImpl += `    return createError(globalObject, Bun::ErrorCode::${code}, builder.toString());\n`;
  concreteImpl += `}`;

  var impls = jsFunctionImpl + "\n" + concreteImpl;
  return {
    declarations,
    impls,
  };
}

// =============================================================================

function isSimpleMapping(mapping: ErrorCodeMapping): mapping is SimpleMapping {
  if (mapping.length == 1 || mapping.length > 2) return true;
  const [, ctor] = mapping;
  return ctor == null || typeof ctor === "function";
}

type NormalizedMapping = ReturnType<typeof normalizeMapping>;

function normalizeMapping(mapping: ErrorCodeMapping) {
  assert(mapping.length > 0);
  if (isSimpleMapping(mapping)) {
    // simple mapping
    var [code, ctor = Error, name = ctor.name, ...extraCtors] = mapping;
    return {
      code,
      ctor,
      name,
      extraCtors,
      message: undefined,
    } as const;
  } else {
    const [code, { ctor = Error, name = ctor.name, message, extraCtors = [] }] = mapping;
    return {
      code,
      ctor,
      name,
      extraCtors,
      message,
    } as const;
  }
}

type TemplateText = {
  kind: "string";
  text: string;
};

type TemplatePlaceholder = {
  kind: "placeholder";
  name: string;
};

type TemplatePart = TemplateText | TemplatePlaceholder;

/**
 * Parse a template like `Unexpected value {value}: {reason}` into a list of
 * {@link TemplatePart}
 *
 * @note does not allow nested braces
 */
function parseTemplate(messageTemplate: string): TemplatePart[] {
  if (!messageTemplate?.length) {
    throw new SyntaxError("Invalid template: template string is empty");
  }

  const parts: TemplatePart[] = [];
  // -1 means we're not inside a brace
  let braceStart = -1;
  let start = 0;

  const BRACE_OPEN = "{".charCodeAt(0);
  const BRACE_CLOSE = "}".charCodeAt(0);

  for (let i = 0; i < messageTemplate.length; i++) {
    const char = messageTemplate.charCodeAt(i);
    switch (char) {
      case BRACE_OPEN: {
        if (braceStart !== -1)
          throw new SyntaxError("Invalid template: an opening brace was found without a closing brace");

        braceStart = i;
        if (i > start) {
          // push text
          parts.push({
            kind: "string",
            text: messageTemplate.slice(start, i),
          });
          start = i;
        }
        break;
      }

      case BRACE_CLOSE: {
        if (braceStart === -1)
          throw new SyntaxError("Invalid template: a closing brace was found without an opening brace");
        parts.push({
          kind: "placeholder",
          name: messageTemplate.slice(braceStart + 1, i),
        });
        braceStart = -1;
        break;
      }

      default: // text
        break;
    }
  }

  if (braceStart !== -1) {
    throw new SyntaxError("Invalid template: an opening brace was found without a closing brace");
  }

  return parts;
}
